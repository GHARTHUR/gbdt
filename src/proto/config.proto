/* Copyright 2016 Jiang Chen <criver@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = 'proto3';

package gbdt;

message Config {
  // Tree building config.
  int32 num_trees = 1;
  int32 num_leaves = 2;
  float shrinkage = 3;
  // The minimum gain to consider split a leaf.
  double min_gain = 4;
  // L2 regularization hyperparameter lambda.
  double l2_lambda = 5;
  // Minimum hessian threshold to consider a split.
  double min_hessian = 21;

  // Sampling config.
  float example_sampling_rate = 6;
  float feature_sampling_rate = 7;

  // Eval config.
  int32 eval_interval = 8;

  // Data config.
  repeated string float_feature = 9;
  repeated string categorical_feature = 10;
  string weight_column = 11;
  string target_column = 12;
  // Whether the binarize targets into {-1, +1}.
  bool binarize_target = 13;
  string group_column = 14;
  // Columns to be loaded in additional to features.
  // These are usually columns needed for loss function computation.
  repeated string additional_float_column = 15;
  repeated string additional_string_column = 16;

  // Loss Func config.
  string loss_func = 17;
  // Pairwise loss func.
  // Average number of pairs per sample. This determines direclty the complexity blowup for
  // pairwise learning algorithm. The time complexity of the gradient computation
  // are roughly pair_sampling_rate * N, where N is the number of examples.
  float pair_sampling_rate = 18;
  // If true, each pair are weighted by the absolute value of their delta target difference.
  bool pair_weight_by_delta_target = 19;
  float lambdamart_dcg_base = 20;
  // Makes each group's weight equal. This is useful to avoid
  // putting disporportionately more weights on groups with more
  // pairs.
  bool equal_group_weight = 22;
}